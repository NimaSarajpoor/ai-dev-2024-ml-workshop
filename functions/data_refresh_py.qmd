---
title: "EIA API - Data Refrsh (Python Version)"
format:
  html:
    code-fold: false
jupyter: python3
---

## Load libraries

```{python}
import eia_api as api
import eia_data 
import pandas as pd
import numpy as np
import requests
import json
import os
import datetime
import plotly.express as px
import great_tables as gt
import dev_fc as dev_fc
import eia_forecast as fc
```



API Settings:
```{python}
raw_json = open("../settings/series.json")
meta_json = json.load(raw_json)
series = pd.DataFrame(meta_json["series"])
api_path = meta_json["api_path"]

facets_template = {
  "parent" : None,
  "subba" : None
}

offset = 2250

eia_api_key = os.getenv('EIA_API_KEY')

meta_path = meta_json["meta_path"]
fc_meta_path = meta_json["fc_meta_path"]
data_path = meta_json["data_path"]
leaderboard_path = meta_json["leaderboard_path"]
forecast_path = meta_json["forecast_path"]
forecast_log_path = meta_json["forecast_log_path"]
```


```{python}
meta_obj = eia_data.get_metadata(api_key = eia_api_key, api_path = api_path, meta_path = meta_path, series = series)

gt.GT(meta_obj.request_meta,)
```

```{python}
m = meta_obj.request_meta
index = meta_obj.last_index + 1
data = None
for i in m.index:

    facets = facets_template
    facets["parent"] = m.at[i, "parent"]
    facets["subba"] = m.at[i, "subba"]
    start = m.at[i, "request_start"]
    end = m.at[i, "end"]

    print(facets)
    if m.at[i, "updates_available"]:
        temp = api.eia_backfill(api_key = eia_api_key, 
            api_path = api_path+ "data", 
            facets = facets, 
            start = start.to_pydatetime(),
            end = end.to_pydatetime(),
            offset = offset) 

        ts_obj = pd.DataFrame(np.arange(start = start, stop = end + datetime.timedelta(hours = 1), step = datetime.timedelta(hours = 1)).astype(datetime.datetime), columns=["index"])
        ts_obj  = ts_obj.merge(temp.data, left_on = "index", right_on = "period", how="left")
        ts_obj.drop("period", axis = 1, inplace= True)
        ts_obj = ts_obj.rename(columns= {"index": "period"})
    else:
        ts_obj = None
        print("No new data is available")

    meta_temp = eia_data.create_metadata(data = ts_obj, start = start, end = end, type = "refresh")

    if ts_obj is None:
        meta_temp["parent"] =  m.at[i, "parent"]
        meta_temp["subba"] =  m.at[i, "subba"]


    if meta_temp["success"]:
        print("Append the new data")
        d = eia_data.append_data(data_path = data_path, new_data = ts_obj, save = True)
        meta_temp["update"] = True
    else:
        meta_temp["update"] = False
        meta_temp["comments"] = meta_temp["comments"] + "The data refresh failed, please check the log; "

    meta_df = pd.DataFrame([meta_temp])
    
    if data is None:
        data = ts_obj
    else:
        data = data._append(ts_obj)

    if i == series.index.start:
        meta_new = meta_df
    else:
        meta_new = meta_new._append(meta_df)

```

```{python}
gt.GT(meta_new,rowname_col = "index")
```


```{python}
meta_updated = eia_data.append_metadata(meta_path = meta_path, meta = meta_new, save = True, init = False)
```

### Plot the Series

We will use Plotly to visualize the series:

```{python}

if data is not None:
    input = data.sort_values(by = ["subba", "period"])
    p = px.line(input, x="period", y="value", color="subba")
    p.show()
else: 
    input = None
    print("No new data is available")
```


## Forecast Refresh

Load metadata
```{python}
freq = meta_json["backtesting"]["freq"]
h = meta_json["backtesting"]["h"]
pi = meta_json["backtesting"]["pi"]
quantiles = meta_json["backtesting"]["quantiles"]
seed = meta_json["backtesting"]["seed"]
mlflow_path = meta_json["backtesting"]["mlflow_path"]
fc_leaderboard = pd.read_csv(leaderboard_path)

```

Check if new observations are available to refresh the forecast 

```{python}
if input is not None:
    for index, row in fc_leaderboard.iterrows():
        subba = row["subba"]
        print(subba)
        fc_start = dev_fc.get_last_fc_start(log_path = forecast_log_path, subba = subba)
        model_label = row["model_label"]
        params = meta_json["backtesting"]["models"][model_label]
        params["h"] = h
        params["freq"] = freq
        params["quantiles"] = quantiles
        params["pi"] = pi
        params["seed"] = seed
        d = None
        d = input[input["subba"] == subba]


        end_series = d['period'].max().floor(freq = "d") - datetime.timedelta(hours = 1)

        if end_series >= fc_start.end:

            end = max(end_series,fc_start.end)

            print("New observations are available, starting to refreshthe forecast")
            d = d[d["period"] <= end]
            if d["period"].isnull().sum() > 0:
                m = d["period"].isnull().sum()
                print("There are " + str(m) + " missing values in the series")
                y = pd.DataFrame(d["period"].isnull())
                n = y[y["period"] == True].index

                for i in n:
                    if i > 24:
                        d.loc[i, "value"] = d.loc[i - 24, "value"]
                    else:
                        d.loc[i, "value"] = d.loc[i + 24, "value"]
                    d.loc[i, "period"] = d.loc[i, "index"]
            d1 = d.sort_values(by = ["period"])


            mlflow_settings = dev_fc.mlflow_params(path = mlflow_path,
                                        experiment_name = "Forecast Dev " + subba,
                                        type = "forecast",
                                        score = False,
                                        append = False,
                                        version = "0.0.1")
            start = end - datetime.timedelta(hours = params["train"])
            ts_train = dev_fc.set_input(input = d, start = start, end = end)
            f = dev_fc.forecast_object()
            f.add_input(input = ts_train) 
            f.add_model_params(model_params =  params)    
            f.add_mlflow_settings(mlflow_settings = mlflow_settings)
            f.create_forecast()
            f.model_meta["subba"] = subba
            f.forecast["subba"] = subba
            print(subba)
            log = dev_fc.append_log(log_path= forecast_log_path, new_log = f.model_meta, save = True, init = False)
            new_fc = dev_fc.append_forecast(fc_path =  forecast_path, fc_new = f, save = True, init = False)
        else:
            print("There are no new observations, skipping forecast refresh")

else: 
    print("No new data is available")   
 
```




## Score the Forecast

```{python}
if input is not None:
    score = score_forecast(data_path = data_path,
    forecast_log_path = forecast_log_path, 
    forecast_path = forecast_path, 
    save = False)
else:
    print("No new data is available, skipping the scoring process")

```